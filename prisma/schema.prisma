// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  PATIENT
  DOCTOR
  MODERATOR
  SURGEON
  ADMIN
}

enum RecordVisibility {
  PRIVATE
  PUBLIC
}

enum DoctorRole {
  PERFORMED
  ASSISTED
  SUPERVISED
  OBSERVED
}

enum FollowUpStatus {
  PENDING
  COMPLETED
  MISSED
}

enum MediaType {
  IMAGE
  PDF
  AUDIO
  VIDEO
  DOCUMENT
}

enum ReminderChannel {
  WHATSAPP
  NOTIFICATION
  EMAIL
  SMS
}

enum ReminderStatus {
  PENDING
  SENT
  FAILED
  CANCELLED
}

enum AuditAction {
  CREATE
  UPDATE
  VIEW
  HIDE
  ARCHIVE
  DELETE
  EXPORT
  SHARE
}

enum NotificationType {
  FOLLOW_UP_REMINDER
  NEW_UPLOAD
  RECORD_UPDATE
  MISSED_APPOINTMENT
  REVIEW_REQUEST
}

model User {
  id            String        @id @default(uuid())
  email         String        @unique
  password      String
  name          String?
  profileImage  String?
  role          UserRole
  isActive      Boolean       @default(true)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  patient       Patient?
  doctor        Doctor?
  moderator     Moderator?
  auditLogs     AuditLog[]
  refreshTokens RefreshToken[]
}

model RefreshToken {
  id            String        @id @default(uuid())
  token         String        @unique
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt     DateTime
  isRevoked     Boolean       @default(false)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@index([userId])
  @@index([token])
}

model Patient {
  id            String        @id @default(uuid())
  userId        String        @unique
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  patientId     String        @unique // System-generated patient ID
  cnic          String        @unique
  fullName      String
  fatherName    String
  contactNumber String
  whatsappNumber String?
  address       String        @db.Text
  
  assignedDoctorId String?
  assignedDoctor   Doctor?     @relation("AssignedPatients", fields: [assignedDoctorId], references: [id])
  
  createdById   String?
  createdBy     Doctor?       @relation("CreatedPatients", fields: [createdById], references: [id])
  
  surgeries     Surgery[]
  uploads       PatientUpload[]
  notifications Notification[]
  privateNotes  PrivateNote[]
  
  isArchived    Boolean       @default(false)
  archivedAt    DateTime?
  archivedBy    String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@index([cnic])
  @@index([assignedDoctorId])
  @@index([createdById])
  @@index([patientId])
  @@index([fullName])
}

model Doctor {
  id            String        @id @default(uuid())
  userId        String        @unique
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  fullName      String
  specialization String?
  contactNumber String
  whatsappNumber String?
  
  assignedPatients Patient[]   @relation("AssignedPatients")
  createdPatients  Patient[]   @relation("CreatedPatients")
  surgeries     Surgery[]
  followUps     FollowUp[]
  privateNotes  PrivateNote[]
  notifications Notification[]
  
  isArchived    Boolean       @default(false)
  archivedAt    DateTime?
  archivedBy    String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@index([fullName])
}

model Moderator {
  id            String        @id @default(uuid())
  userId        String        @unique
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  fullName      String
  contactNumber String
  whatsappNumber String?
  
  canAddRecords Boolean       @default(true)
  canEditRecords Boolean      @default(false)
  canDeleteRecords Boolean    @default(false)
  
  isArchived    Boolean       @default(false)
  archivedAt    DateTime?
  archivedBy    String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@index([fullName])
}

model Surgery {
  id              String          @id @default(uuid())
  patientId       String
  patient         Patient         @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  doctorId        String
  doctor          Doctor          @relation(fields: [doctorId], references: [id])
  
  diagnosis       String
  customDiagnosis String?         // For custom entries not in predefined list
  briefHistory    String          @db.Text
  preOpFindings   String          @db.Text
  procedureName   String
  customProcedure String?         // For custom procedures not in predefined list
  procedureDetails String         @db.Text
  doctorRole      DoctorRole
  
  surgeryDate     DateTime
  surgeryTime     String?         // Store time separately if needed
  
  followUps       FollowUp[]
  visibility      RecordVisibility @default(PUBLIC)
  
  // PDF Export Settings
  allowPatientExport Boolean      @default(true)
  
  isArchived      Boolean         @default(false)
  archivedAt      DateTime?
  archivedBy      String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  createdBy       String
  lastModifiedBy  String?
  
  @@index([patientId])
  @@index([doctorId])
  @@index([surgeryDate])
  @@index([diagnosis])
  @@index([procedureName])
}

model FollowUp {
  id              String          @id @default(uuid())
  surgeryId       String
  surgery         Surgery         @relation(fields: [surgeryId], references: [id], onDelete: Cascade)
  
  doctorId        String
  doctor          Doctor          @relation(fields: [doctorId], references: [id])
  
  followUpDate    DateTime
  scheduledTime   String?
  description     String          @db.Text
  observations    String?         @db.Text
  status          FollowUpStatus  @default(PENDING)
  
  // Track updates from both sides
  lastDoctorUpdate DateTime?
  lastPatientUpdate DateTime?
  
  media           Media[]
  privateNotes    PrivateNote[]
  reminders       Reminder[]
  visibility      RecordVisibility @default(PUBLIC)
  
  isArchived      Boolean         @default(false)
  archivedAt      DateTime?
  archivedBy      String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  createdBy       String
  lastModifiedBy  String?
  
  @@index([surgeryId])
  @@index([doctorId])
  @@index([followUpDate])
  @@index([status])
}

model Media {
  id            String        @id @default(uuid())
  followUpId    String
  followUp      FollowUp      @relation(fields: [followUpId], references: [id], onDelete: Cascade)
  
  fileName      String
  originalName  String
  fileType      MediaType
  mimeType      String
  fileUrl       String
  thumbnailUrl  String?       // For images/videos
  fileSize      Int
  duration      Int?          // For audio/video in seconds
  
  // AI transcription for audio
  hasTranscription Boolean    @default(false)
  transcriptionText String?   @db.Text
  
  uploadedBy    String
  uploadedByRole UserRole
  uploadedByName String?      // Denormalized for quick access
  
  // Visibility control
  visibility    RecordVisibility @default(PUBLIC)
  includeInExport Boolean     @default(true)
  
  isArchived    Boolean       @default(false)
  archivedAt    DateTime?
  createdAt     DateTime      @default(now())
  
  @@index([followUpId])
  @@index([uploadedBy])
  @@index([fileType])
  @@index([createdAt])
}

model PatientUpload {
  id            String        @id @default(uuid())
  patientId     String
  patient       Patient       @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  fileName      String
  originalName  String
  fileType      MediaType
  mimeType      String
  fileUrl       String
  thumbnailUrl  String?
  fileSize      Int
  description   String?       @db.Text
  category      String?       // e.g., "lab_report", "xray", "prescription"
  
  // Review tracking
  isReviewed    Boolean       @default(false)
  reviewedBy    String?
  reviewedByName String?
  reviewedAt    DateTime?
  reviewComment String?       @db.Text
  
  // Notification tracking
  notificationSent Boolean    @default(false)
  notificationReadAt DateTime?
  
  isArchived    Boolean       @default(false)
  archivedAt    DateTime?
  createdAt     DateTime      @default(now())
  
  @@index([patientId])
  @@index([isReviewed])
  @@index([notificationSent])
  @@index([createdAt])
}

model PrivateNote {
  id            String        @id @default(uuid())
  doctorId      String
  doctor        Doctor        @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  
  patientId     String
  patient       Patient       @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  followUpId    String?
  followUp      FollowUp?     @relation(fields: [followUpId], references: [id], onDelete: Cascade)
  
  surgeryId     String?       // Can also attach to surgery directly
  title         String?
  content       String        @db.Text
  
  // Audio notes
  audioUrl      String?
  audioDuration Int?          // In seconds
  hasTranscription Boolean    @default(false)
  transcriptionText String?   @db.Text
  
  // Attachments for private notes
  attachments   Json?         // Array of {fileName, fileUrl, fileType}
  
  isArchived    Boolean       @default(false)
  archivedAt    DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@index([doctorId])
  @@index([patientId])
  @@index([followUpId])
  @@index([surgeryId])
  @@index([createdAt])
}

model Reminder {
  id            String        @id @default(uuid())
  
  // What the reminder is about
  entityType    String        // "follow_up", "surgery", "patient_upload"
  entityId      String
  followUpId    String?
  followUp      FollowUp?     @relation(fields: [followUpId], references: [id], onDelete: Cascade)
  
  // Who receives the reminder
  recipientId   String
  recipientRole UserRole
  recipientName String?
  recipientPhone String?
  
  // Reminder details
  title         String
  message       String        @db.Text
  scheduledFor  DateTime
  sentAt        DateTime?
  
  // Configuration
  channel       ReminderChannel
  status        ReminderStatus  @default(PENDING)
  
  // Repeat settings
  isRecurring   Boolean       @default(false)
  recurringPattern String?    // e.g., "weekly", "monthly"
  daysBefore    Int?          // Days before appointment
  
  // Tracking
  attempts      Int           @default(0)
  lastAttemptAt DateTime?
  errorMessage  String?
  
  createdBy     String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@index([scheduledFor, status])
  @@index([recipientId])
  @@index([followUpId])
  @@index([status])
  @@index([channel])
}

model Notification {
  id            String        @id @default(uuid())
  
  // Recipient
  recipientId   String
  recipientRole UserRole
  patientId     String?
  patient       Patient?      @relation(fields: [patientId], references: [id], onDelete: Cascade)
  doctorId      String?
  doctor        Doctor?       @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  
  // Notification content
  type          NotificationType
  title         String
  message       String        @db.Text
  
  // Related entity
  entityType    String?       // "patient_upload", "follow_up", "surgery"
  entityId      String?
  
  // Status
  isRead        Boolean       @default(false)
  readAt        DateTime?
  
  // Badge/Priority
  priority      String        @default("normal") // "low", "normal", "high", "urgent"
  showBadge     Boolean       @default(true)
  badgeColor    String        @default("red") // "red", "green", "blue", "yellow"
  
  createdAt     DateTime      @default(now())
  expiresAt     DateTime?
  
  @@index([recipientId, isRead])
  @@index([patientId])
  @@index([doctorId])
  @@index([type])
  @@index([createdAt])
}

model AuditLog {
  id            String        @id @default(uuid())
  userId        String?
  user          User?         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  action        AuditAction
  entityType    String        // "patient", "surgery", "followup", "media", etc.
  entityId      String
  
  // Detailed change tracking
  changes       Json?         // Before/after values
  description   String?       @db.Text
  
  // Request metadata
  ipAddress     String?
  userAgent     String?
  requestMethod String?
  requestPath   String?
  
  // Result tracking
  success       Boolean       @default(true)
  errorMessage  String?
  
  createdAt     DateTime      @default(now())
  
  @@index([userId])
  @@index([entityType, entityId])
  @@index([action])
  @@index([createdAt])
  @@index([success])
}

model PDFExport {
  id            String        @id @default(uuid())
  
  // Who requested the export
  requestedBy   String
  requestedByRole UserRole
  
  // What was exported
  patientId     String
  surgeryIds    String[]      // Array of surgery IDs included
  followUpIds   String[]      // Array of follow-up IDs included
  
  // Export configuration
  includeConfig Json          // {diagnosis: true, images: false, privateNotes: false, etc.}
  exportType    String        // "patient_copy", "doctor_copy", "full_report"
  
  // PDF details
  fileName      String
  fileUrl       String
  fileSize      Int
  
  // Security
  isPasswordProtected Boolean @default(false)
  passwordHash  String?
  expiresAt     DateTime?
  downloadCount Int           @default(0)
  maxDownloads  Int?
  
  createdAt     DateTime      @default(now())
  
  @@index([patientId])
  @@index([requestedBy])
  @@index([createdAt])
}

model SystemSetting {
  id            String        @id @default(uuid())
  key           String        @unique
  value         String        @db.Text
  dataType      String        @default("string") // "string", "number", "boolean", "json"
  category      String?       // "reminder", "notification", "export", "security"
  description   String?
  
  updatedBy     String?
  updatedAt     DateTime      @updatedAt
  createdAt     DateTime      @default(now())
  
  @@index([category])
  @@index([key])
}
